---
layout: post
title:  "논리/수학"
date:   2018-11-03 02:26:28
categories: Programming
---
0.서론 - 프로그밍과 논리/수학

프로그래밍의 어려운 점 두가지

-프로그래밍 문법과 라이브러리 사용 

-논리

논리
hard vs soft logic
카드 문제 
- 사실 : 모든 카드의 한쪽에는 알파벳, 다른 쪽에는 숫자
- 주장 : 만약 한쪽이 D이면 반대쪽은 3
- 문제 : 주장이 사실인지 확인하기 위해 아래 카드 중 반드시 뒤집어봐야 하는 카드는 몇개이고 어느것인가?
D F 3 7
-정답 D와 7

맥주집 문제
- 규칙 : 20세 이하인 사람은 맥주를 마실 수 없음
- 문제 : 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇명 이고 누구인가? 
17세, 31세 콜라, 맥주
-정답 : 17세와 맥주

카드 문제와 맥주집 문제의 비교
-맥주집 문제가 훨씬 풀기 쉽다
-사실, 두 문제는 완전히 같은 문제임 즉, 논리적 구상은 완전히 동일함

- 왜 맥주집 문제가 풀기 쉬운가?
- 논리 구조를 정확히 이해하고 맥주집 문제를 푸는 사람은 카드 문제를 똑같이 풀 수 있음
- 즉, 맥주집 문제를 풀 때 논리를 사용한 것이 아니다!

HARD VS SOFT LOGIC
- 맥주집 문제를 풀 때는 직관을 사용한 것
- 직관은 논리적인 느낌을 주는 것
- 직관의 장점은 [익숙한 상황예시]빠른다는 것
- 직관은 단점은 정확하지 않다는 것 [가끔은 익숙한 상황에서도 틀림]
- 또 다른 단점은 강한 착각을 일으킨다는 것

과자와 버스
"너 과자 몇 개 먹었니?" vs "버스 타려고 하는데 천원 있니?"

- 두 질문은 같은 표현을 사용하지만, 
하나는 정확한 개수를 요구하고 다른 하나는 천원 이상(정도)있는지 물어 보는 것

- 직관만 이용해서 논리를 일상생활에서 사용 하고 있음

토플과 복권
"합격하려면 토플500점 이상 혹은 토익 600점 이상이 필요" vs
"복권에 당첨되면 자동차 혹은 천만원을 줍니다"

- 두 말은 같은 표현을 사용하지만 논리적인 내용이 다름
- 이것이 직관으로 들어와 있기 때문에 논리적인 과정을 잊어버리고 일상생활에서 사용하고 있음, 익숙하지 않은 프로그래밍 과정에서 사용하면 어려워진다.

일상생활에서는 soft logic이 빠르기 때문에 유용
- 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정

프로그래밍은 hard logic을 사용
- 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
- 사용되는 수 많은 알고리즘들을 이해하기 위해선느 hard logic이 필요

- 직관으로 프로그래밍을 이해하려고 하면 어렵다..

오해의 근원
- soft logic으로 알고리즘을 이해하려고 하는 것 

알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문

증명을 봐도 이해가 안되는 것은 직관으로 이해하려고 하기 때문

가끔 직관적으로 이해되는 알고리즘이 있지만 조금만 어려워 지면 직관으로 완전히 이해하는 것은 사실상 불가능하다.

논리 연습
-문제 1 : 다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오.
1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.  ==> 정답 : 참
	- p 이면 q이다 라는 명제에서 p가 거짓이면 전체는 참이다. 
2. 만약 121313131239이 prime number라면, 2는 짝수이다. ==> 정답 : 참 
	- p 이면 q이다 라면 명제에서 q가 사실이면 전체는 참이다. 

-문제 2 : p와 q가 명제이고 p->q가 거짓이라고 하자, 다음 명제식의 참 거짓은 어떻게 되는가?
	1. ~p ->q  2. pvq  3.q->p

-문제 3 : 역, 이, 대우 쓰시오


증명이란?
- 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
- 증명에 대한 수 많은 오해가 p->q를 p<->q와 혼동하는 것에서 일어남

수학적 귀납법
- 수학적 귀납법의 기본형 : p(1)이 참이고, p(n)->p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다.
- 수학적 귀납법의 강한 형태 : P(1)이 참이고, P(1)ㅅP(2)ㅅ..ㅅ P(N)->P(N+1)이 참이면 P(N)은 모든 자연수 N에 대해서 참이다.
- 다음 함수가 1부터 X까지의 합을 계산함을 증명해보자
~~~
int sum(int x)
{
	if(x<=0) return 0;
	return x + sum(x-1);
}
~~~
